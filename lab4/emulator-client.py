# Import SDK packages
from AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTClient
import boto3
import time
import json
import pandas as pd
import datetime
import numpy as np
from threading import Lock 

import random

################################################### 
# In case we need Boto3 functions on IoT client
# https://boto3.amazonaws.com/v1/documentation/api/latest/guide/quickstart.html
from botocore.config import Config

# my_config = Config(
#     region_name = 'us-west-2',
#     signature_version = 'v4',
#     retries = {
#         'max_attempts': 10,
#         'mode': 'standard'
#     }
# )

thingGroup = 'CS498'
thingType = 'wearable'

# awsIoTClient = boto3.client('iot', config=my_config)
###################################################

#Starting and end index, modify this
device_st = 0
device_end = 49

# get IoT current logging levels, format them as JSON, and write them to stdout
# response = awsIoTClient.get_v2_logging_options()
# print(json.dumps(response, indent=4))

#Path to the dataset, modify this
data_path = "data/class_{}.csv"
randMsg = ['message a','message b','message c','message d']

# after `aws configure`
# obtained from `aws iot describe-endpoint --endpoint-type iot:Data-ATS` for Amazon Trust Services Endpoints (preferred)
my_iotEndpoint = "a12nbrmsd21s59-ats.iot.us-west-2.amazonaws.com"
# downloaded from https://www.amazontrust.com/repository/AmazonRootCA1.pem
# as per https://docs.aws.amazon.com/iot/latest/developerguide/server-authentication.html?icmpid=docs_iot_console#server-authentication-certs
rootCApath='./AmazonRootCA1.pem'
# rootCApath="./G2-RootCA1.pem" #cross-signed

# Path to certificates, automatically generated by createThing-Cert.py
certificate_formatter = "./certificates/device_{}/device_{}.certificate.pem"
key_formatter = "./certificates/device_{}/device_{}.private.pem"


class MQTTClient:
	def __init__(self, device_id, cert, key):
		# For certificate based connection
		self.device_id = str(device_id)
		self.state = 0
		self.client = AWSIoTMQTTClient(self.device_id)
		self.client.configureEndpoint(my_iotEndpoint, 8883)
		self.client.configureCredentials(rootCApath, key, cert)
		self.client.configureOfflinePublishQueueing(-1)  # Infinite offline Publish queueing
		self.client.configureDrainingFrequency(2)  # Draining: 2 Hz
		self.client.configureConnectDisconnectTimeout(10)  # 10 sec
		self.client.configureMQTTOperationTimeout(5)  # 5 sec
		self.client.onMessage = self.customOnMessage
		

	def customOnMessage(self,message):
		print("client {} received from topic {} - payload {}\n".format(
			self.device_id, message.topic, message.payload.decode()), end = " ")

		#Don't delete this line
		self.client.disconnectAsync()


	# Suback callback
	def customSubackCallback(self,mid, data):
		#You don't need to write anything here
	    pass


	# Puback callback
	def customPubackCallback(self,mid):
		#You don't need to write anything here
	    pass


	def publish(self):
		#TODO4: fill in this function for your publish
		# QoS: 0 -> <= 1  1 -> >= 1
		qosLevel = 0
		self.client.connect()
		# creates topic string per device, such as `CS498/wearable/0`
		topicTuple = (thingGroup, thingType, self.device_id)
		topicString = '/'.join(topicTuple)

		# TODO: this is not correct! Needs to load values from data/csv. But how?
		json_data = {}
		msgIndex = self.state-1 # state is 1 based, msg array is zero based
		json_data['item'] = randMsg[msgIndex]
		payload = json.dumps(json_data)

		#optional debug
		print('Device {} Topic: {}'.format(self.state,topicString))
		print('Device {} Payload: {}'.format(self.state,payload))
		
		# subscribe
		self.client.subscribeAsync(topicString, qosLevel, ackCallback=self.customSubackCallback)
		# publish
		self.client.publishAsync(topicString, payload, qosLevel, ackCallback=self.customPubackCallback)



# Don't change the code below
print("wait")
lock = Lock()
data = []
for i in range(5):
	a = pd.read_csv(data_path.format(i))
	data.append(a)

clients = []
for device_id in range(device_st, device_end):
	client = MQTTClient(device_id,cert = certificate_formatter.format(device_id,device_id), key = key_formatter.format(device_id,device_id))
	clients.append(client)



states_for_test = [3, 0, 0, 0, 4, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0, 3, 2, 3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
 0, 0, 0, 4, 0, 4, 3, 0, 0, 3, 0, 2, 0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,\
  2, 4, 1, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 4, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0,\
   0, 1, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,\
    0, 0, 4, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 3, 0,\
     0, 4, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0,\
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 2,\
       0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 0,\
        0, 1, 2, 1, 0, 0, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 1, 0, 3, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\
         0, 0, 4, 4, 0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 2, 0, 0,\
          0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0,\
           0, 4, 1, 1, 0, 0, 0, 1, 3, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\
            2, 0, 2, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 4]
s1,s2,s3,s4 = [],[],[],[]
for i in range(device_st,device_end):
	if i < 500:
		clients[i].state = states_for_test[i]
		if states_for_test[i] == 1: s1.append(i)
		elif states_for_test[i] == 2: s2.append(i)
		elif states_for_test[i] == 3: s3.append(i)
		elif states_for_test[i] == 4: s4.append(i)


print("Users at state 1: ", s1)
print("Users at state 2: ", s2)
print("Users at state 3: ", s3)
print("Users at state 4: ", s4)
 


print("send now?")
x = input()
if x == "s":
	for i,c in enumerate(clients):
		c.publish()
	print("done")
elif x == "d":
	for c in clients:
		c.disconnect()
		print("All devices disconnected")
else:
	print("wrong key pressed")

time.sleep(10)